{"version":3,"sources":["webpack:///webpack/bootstrap 82421f8d57308ee51d94","webpack:///./entry.js","webpack:///./node_modules/boolean-logic/boolean-logic.js"],"names":["benchmark","wff","resultDiv","beforeParseDate","Date","beforeParseTime","getTime","parsedWff","_parse","afterParseDate","afterParseTime","parseDuration","beforeGenerateModelsDate","beforeGenerateModelsTime","models","_generateModels","afterGenerateModelsDate","afterGenerateModelsTime","generateModelsDuration","beforeCheckDate","beforeCheckTime","result","_checkModels","afterCheckDate","afterCheckTime","checkDuration","Boolean","resultString","key","innerHTML","generateWffWithOnes","connectives","numAtoms","addNegation","Math","floor","random","connIdx","firstNumAtoms","secondNumAtoms","firstWff","secondWff","negatumWff","generateWffNotDistinct","wffArray","split","i","length","join","generateWff","numNotDistinct","_atomics","negationProbability","document","addEventListener","generateButton","getElementById","submitButton","wffTextarea","wffLengthInput","e","preventDefault","wffLength","parseInt","value"],"mappings":"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f,CAAgC,OAAhC,EAAyC,aAAK;AAC5CM,MAAEC,cAAF;AACA,QAAMC,YAAYC,SAASJ,eAAeK,KAAxB,CAAlB;AACA,QAAM/D,MAAMgD,YAAYa,SAAZ,CAAZ;AACAJ,gBAAYM,KAAZ,GAAoB/D,GAApB;AACD,GALD;;AAOAwD,eAAaH,gBAAb,CAA8B,OAA9B,EAAuC,aAAK;AAC1CM,MAAEC,cAAF;AACA,QAAMxC,SAASrB,UAAU0D,YAAYM,KAAtB,EAA6B9D,SAA7B,CAAf;AACD,GAHD;AAID,CAjBD;;AAmBA;AACA;AACA;;AAEA;AACA;AACA,gC;;;;;;;AC5IA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA","file":"./script.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 82421f8d57308ee51d94","import Logic, { isSat } from 'boolean-logic';\n\nexport const benchmark = (wff, resultDiv) => {\n  const beforeParseDate = new Date();\n  const beforeParseTime = beforeParseDate.getTime();\n  const parsedWff = Logic._parse(wff, true);\n  const afterParseDate = new Date();\n  const afterParseTime = afterParseDate.getTime();\n  const parseDuration = afterParseTime - beforeParseTime;\n\n  const beforeGenerateModelsDate = new Date();\n  const beforeGenerateModelsTime = beforeGenerateModelsDate.getTime();\n  if (!parsedWff) {\n    return;\n  }\n  const models = Logic._generateModels(wff);\n  const afterGenerateModelsDate = new Date();\n  const afterGenerateModelsTime = afterGenerateModelsDate.getTime();\n  const generateModelsDuration =\n    afterGenerateModelsTime - beforeGenerateModelsTime;\n\n  const beforeCheckDate = new Date();\n  const beforeCheckTime = beforeCheckDate.getTime();\n  const result = Logic._checkModels(parsedWff, models, true);\n  const afterCheckDate = new Date();\n  const afterCheckTime = afterCheckDate.getTime();\n  const checkDuration = afterCheckTime - beforeCheckTime;\n\n  if (Boolean(result)) {\n    let resultString = '';\n    for (let key in result) {\n      resultString = `${resultString}<br />&nbsp;&nbsp;${key}: ${result[key]}`;\n    }\n    resultDiv.innerHTML = `\n      <p>The formula is satisfiable.</p>\n      <p>The first model found was:</p>\n      <p>{${resultString}<br />}</p>\n      <p>It took ${parseDuration} milliseconds to parse the wff.</p>\n      <p>\n        It took ${generateModelsDuration} milliseconds to generate all models of this wff.</p>\n      <p>It took ${checkDuration} milliseconds to find the above model.</p>\n      <p>It took ${generateModelsDuration +\n        checkDuration} milliseconds to generate all models of this wff and to find the above model.</p>\n      <p>It took ${parseDuration +\n        generateModelsDuration +\n        checkDuration} milliseconds to do everything.</p>\n    `;\n  } else {\n    resultDiv.innerHTML = `\n      <p>The formula isn't satisfiable</p>\n      <p>It took ${parseDuration} milliseconds to parse the wff.</p>\n      <p>It took ${generateModelsDuration} milliseconds to generate all models of this wff.</p>\n      <p>It took ${checkDuration} milliseconds to check every model.</p>\n      <p>It took ${generateModelsDuration +\n        checkDuration} milliseconds to generate all models of this wff and to check all of them.</p>\n      <p>It took ${parseDuration +\n        generateModelsDuration +\n        checkDuration} milliseconds to do everything.</p>\n    `;\n  }\n};\n\nexport const generateWffWithOnes = numAtoms => {\n  const connectives = ['N', 'A', 'O', 'X', 'T', 'B'];\n  if (numAtoms === 1) {\n    const addNegation = Math.floor(Math.random()) > 0.5 ? true : false;\n    if (addNegation) {\n      return '(N1)';\n    } else {\n      return '1';\n    }\n  } else if (numAtoms === 2) {\n    let connIdx = Math.floor(Math.random() * 5) + 1;\n    return `(1${connectives[connIdx]}1)`;\n  } else {\n    let connIdx = Math.floor(Math.random() * 6);\n    if (connIdx > 0) {\n      let firstNumAtoms = Math.floor(Math.random() * (numAtoms - 1)) + 1;\n      let secondNumAtoms = numAtoms - firstNumAtoms;\n      let firstWff = generateWffWithOnes(firstNumAtoms);\n      let secondWff = generateWffWithOnes(secondNumAtoms);\n      return `(${firstWff}${connectives[connIdx]}${secondWff})`;\n    } else {\n      let negatumWff = generateWffWithOnes(numAtoms);\n      return `(N${negatumWff})`;\n    }\n  }\n};\n\nexport const generateWffNotDistinct = numAtoms => {\n  const wff = generateWffWithOnes(numAtoms);\n  const wffArray = wff.split('');\n  for (let i = 0; i < wffArray.length; i++) {\n    if (wffArray[i] === '1') {\n      wffArray[i] = Math.floor(Math.random() * numAtoms) + 1;\n    }\n  }\n  return wffArray.join('');\n};\n\nexport const generateWff = numAtoms => {\n  let numNotDistinct = Math.floor(Math.random() * numAtoms * 10) + 1;\n  let wff = generateWffNotDistinct(numNotDistinct);\n  while (Logic._atomics(wff).length !== numAtoms) {\n    numNotDistinct = Math.floor(Math.random() * numAtoms * 10) + 1;\n    wff = generateWffNotDistinct(numNotDistinct);\n  }\n  const negationProbability = Math.random();\n  if (negationProbability < 0.5) {\n    return wff;\n  } else {\n    return `(N${wff})`;\n  }\n};\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const generateButton = document.getElementById('generateButton');\n  const submitButton = document.getElementById('submitButton');\n  const wffTextarea = document.getElementById('wffTextarea');\n  const wffLengthInput = document.getElementById('wffLength');\n  const resultDiv = document.getElementById('result');\n  generateButton.addEventListener('click', e => {\n    e.preventDefault();\n    const wffLength = parseInt(wffLengthInput.value);\n    const wff = generateWff(wffLength);\n    wffTextarea.value = wff;\n  });\n\n  submitButton.addEventListener('click', e => {\n    e.preventDefault();\n    const result = benchmark(wffTextarea.value, resultDiv);\n  });\n});\n\n// const wff = generateWff(15);\n// console.log(`Testing this formula: '${wff}'`);\n// benchmark(wff);\n\n// window.generateWff = generateWff;\n// window.generateWffWithOnes = generateWffWithOnes;\n// window.benchmark = benchmark;\n\n\n\n// WEBPACK FOOTER //\n// ./entry.js","class Logic {\n  constructor(value) {\n    this.value = value;\n    this.parent = null;\n    this.children = [];\n  }\n\n  setParent(parent) {\n    if (this.parent === parent) {\n      return;\n    }\n\n    if (this.parent) {\n      const children = this.parent.children;\n      children._remove(this);\n    }\n\n    this.parent = parent;\n\n    if (this.parent) {\n      this.parent.children.push(this);\n    }\n  }\n\n  addChild(child) {\n    child.setParent(this);\n  }\n\n  removeChild(child) {\n    if (this.children.includes(child)) child.setParent(null);\n  }\n\n  atomic() {\n    return this.children.length === 0 && Logic._isAtomic(this.value);\n  }\n\n  wff() {\n    const connectives = Object.keys(this.constructor._connectives);\n    if (!this.atomic() && !connectives.includes(this.value)) {\n      return false;\n    } else if (this.atomic()) {\n      return true;\n    } else if (\n      this.value === 'N' &&\n      this.children.length === 1 &&\n      this.children[0].wff()\n    ) {\n      return true;\n    } else if (\n      this.constructor._binaryConns.includes(this.value) &&\n      this.children.length === 2 &&\n      this.children[0].wff() &&\n      this.children[1].wff()\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  isTrue(model) {\n    model = model || {};\n    const modelValues = Object.keys(model).map(key => model[key]);\n    for (let i = 0; i < modelValues.length; i++) {\n      if (modelValues[i] !== true && modelValues[i] !== false) {\n        return;\n      }\n    }\n\n    const fullModel = Object.assign(\n      {},\n      model || {},\n      this.constructor._booleans\n    );\n    if (!this.wff()) {\n      return;\n    } else if (this.atomic()) {\n      return fullModel[this.value];\n    } else {\n      const childOne = this.children[0].isTrue(model);\n      let childTwo;\n      if (this.children[1]) childTwo = this.children[1].isTrue(model);\n      const connective = this.constructor._connectives[this.value];\n      return connective(childOne, childTwo);\n    }\n  }\n}\n\nLogic.isTrue = function(wff, model) {\n  const parsed = Logic._parse(wff);\n  if (!parsed) {\n    return;\n  }\n  return parsed.isTrue(model);\n};\n\nLogic.isSat = function(wff, returnModel) {\n  const parsedWff = Logic._parse(wff);\n  if (!parsedWff) {\n    return;\n  }\n  const models = this._generateModels(wff);\n  return this._checkModels(parsedWff, models, returnModel);\n};\n\nLogic._checkModels = function(parsedWff, models, returnModel) {\n  for (let i = 0; i < models.length; i++) {\n    if (parsedWff.isTrue(models[i])) {\n      return returnModel ? models[i] : true;\n    }\n  }\n  return false;\n};\n\nLogic._booleans = {\n  t: true,\n  f: false,\n};\n\nLogic._binaryConns = ['A', 'O', 'T', 'B', 'X'];\n\nLogic._vocabulary = Logic._binaryConns.concat(['N', '(', ')', 't', 'f']);\n\nLogic._connectives = {\n  A: (sentOne, sentTwo) => sentOne && sentTwo,\n  O: (sentOne, sentTwo) => sentOne || sentTwo,\n  T: (sentOne, sentTwo) => !sentOne || sentTwo,\n  B: (sentOne, sentTwo) => (!sentOne || sentTwo) && (!sentTwo || sentOne),\n  X: (sentOne, sentTwo) => (!sentOne && sentTwo) || (sentOne && !sentTwo),\n  N: sentence => !sentence,\n};\n\nLogic._generateModels = function(wff) {\n  const atomics = this._atomics(wff);\n  const subsets = this._subsets(atomics);\n  return subsets.map(subset => {\n    const newModel = {};\n    atomics.forEach(atomic => {\n      if (subset.includes(atomic)) {\n        newModel[atomic] = false;\n      } else {\n        newModel[atomic] = true;\n      }\n    });\n    return newModel;\n  });\n};\n\nLogic._atomics = function(wff) {\n  wff = this._ensureIsArray(wff);\n  if (!wff) {\n    return;\n  }\n  const atomics = [];\n  wff.forEach(el => {\n    if (this._isAtomic(el) && !atomics.includes(el)) {\n      atomics.push(el);\n    }\n  });\n  return atomics;\n};\n\nLogic._parse = function(wff) {\n  this._ensureIsLegal(wff);\n  wff = Logic._ensureIsArray(wff);\n  if (!wff) {\n    throw 'Argument must be either a string or an array';\n  }\n  const mainConnectiveIdx = this._mainConnectiveIdx(wff);\n  const mainConnective = wff[mainConnectiveIdx];\n  if (wff.length === 1 && Logic._isAtomic(wff[0])) {\n    return new Logic(wff[0]);\n  } else if (\n    wff[0] === '(' &&\n    wff.length > 3 &&\n    this._matchingClosingParensIdx(wff, 0) === wff.length - 1\n  ) {\n    if (\n      wff[1] === '(' &&\n      this._matchingClosingParensIdx(wff, 1) === wff.length - 2\n    ) {\n      return;\n    } else {\n      return this._parse(wff.slice(1, wff.length - 1));\n    }\n  } else if (mainConnectiveIdx === 0) {\n    const prejacent = this._parse(wff.slice(1));\n    const connective = new Logic(wff[mainConnectiveIdx]);\n    if (prejacent) {\n      connective.addChild(prejacent);\n      return connective;\n    }\n  } else if (mainConnectiveIdx) {\n    const firstConjunct = this._parse(wff.slice(0, mainConnectiveIdx));\n    const secondConjunct = this._parse(wff.slice(mainConnectiveIdx + 1));\n    if (firstConjunct && secondConjunct) {\n      const connective = new Logic(mainConnective);\n      if (mainConnective) {\n        connective.addChild(firstConjunct);\n        connective.addChild(secondConjunct);\n        return connective;\n      }\n    }\n  }\n};\n\nLogic._parseString = function(str) {\n  const parsed = [];\n  for (let i = 0; i < str.length; i++) {\n    if (this._vocabulary.includes(str[i])) {\n      parsed.push(str[i]);\n    } else {\n      let subStr = '';\n      for (\n        let j = i;\n        j < str.length && !this._vocabulary.includes(str[j]);\n        j++\n      ) {\n        subStr += str[j];\n        i = j;\n      }\n      if (this._isAtomic(subStr)) {\n        parsed.push(subStr);\n      } else {\n        return;\n      }\n    }\n  }\n  return parsed;\n};\n\nLogic._isAtomic = function(str) {\n  if (['t', 'f'].includes(str) || !isNaN(parseInt(str))) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nLogic._mainConnectiveIdx = function(sentArr) {\n  const binaryConns = this._binaryConns;\n  if (sentArr.length === 1) {\n    return;\n  } else if (sentArr[0] === 'I') {\n    const thenIdx = this._mainConnectiveIdx(sentArr.slice(1));\n    if (sentArr[thenIdx + 1] === 'T') {\n      return thenIdx + 1;\n    } else {\n      return;\n    }\n  } else if (\n    sentArr[0] === '(' &&\n    this._matchingClosingParensIdx(sentArr, 0) === sentArr.length - 1\n  ) {\n    if (\n      sentArr[1] === '(' &&\n      this._matchingClosingParensIdx(sentArr, 1) === sentArr.length - 2\n    ) {\n      return;\n    } else {\n      return this._mainConnectiveIdx(sentArr.slice(1, sentArr.length - 1)) + 1;\n    }\n  } else if (\n    sentArr.length === 2 &&\n    sentArr[0] === 'N' &&\n    Logic._isAtomic(sentArr[1])\n  ) {\n    return 0;\n  } else if (\n    sentArr[0] === 'N' &&\n    sentArr[1] === '(' &&\n    this._matchingClosingParensIdx(sentArr, 1) === sentArr.length - 1\n  ) {\n    return 0;\n  } else if (\n    sentArr[0] === 'N' &&\n    sentArr[1] === 'N' &&\n    this._mainConnectiveIdx(sentArr.slice(1)) === 0\n  ) {\n    return 0;\n  } else if (sentArr[0] === 'N' && this._mainConnectiveIdx(sentArr.slice(1))) {\n    return this._mainConnectiveIdx(sentArr.slice(1)) + 1;\n  } else if (\n    sentArr.length === 3 &&\n    Logic._isAtomic(sentArr[0]) &&\n    binaryConns.includes(sentArr[1]) &&\n    Logic._isAtomic(sentArr[2])\n  ) {\n    return 1;\n  } else if (\n    sentArr.length === 3 &&\n    Logic._isAtomic(sentArr[0]) &&\n    binaryConns.includes(sentArr[1]) &&\n    Logic._isAtomic(sentArr[2])\n  ) {\n    return 1;\n  } else if (\n    Logic._isAtomic(sentArr[0]) &&\n    binaryConns.includes(sentArr[1]) &&\n    sentArr[2] === '(' &&\n    this._matchingClosingParensIdx(sentArr, 2) === sentArr.length - 1\n  ) {\n    return 1;\n  } else if (\n    Logic._isAtomic(sentArr[0]) &&\n    binaryConns.includes(sentArr[1]) &&\n    sentArr[2] === 'N'\n  ) {\n    return 1;\n  } else if (\n    Logic._isAtomic(sentArr[0]) &&\n    binaryConns.includes(sentArr[1]) &&\n    sentArr[this._mainConnectiveIdx(sentArr.slice(2)) + 2] === sentArr[1]\n  ) {\n    return 1;\n  } else if (sentArr[0] === '(') {\n    const matchingClosingParensIdx = this._matchingClosingParensIdx(sentArr, 0);\n    if (!matchingClosingParensIdx) {\n      return undefined;\n    } else if (\n      binaryConns.includes(sentArr[matchingClosingParensIdx + 1]) &&\n      Logic._isAtomic(sentArr[matchingClosingParensIdx + 2]) &&\n      sentArr.length === matchingClosingParensIdx + 3\n    ) {\n      return matchingClosingParensIdx + 1;\n    } else if (\n      binaryConns.includes(sentArr[matchingClosingParensIdx + 1]) &&\n      sentArr[matchingClosingParensIdx + 2] === 'N'\n    ) {\n      return matchingClosingParensIdx + 1;\n    } else if (\n      binaryConns.includes(sentArr[matchingClosingParensIdx + 1]) &&\n      sentArr[matchingClosingParensIdx + 2] === '(' &&\n      this._matchingClosingParensIdx(sentArr, matchingClosingParensIdx + 2) ===\n        sentArr.length - 1\n    ) {\n      return matchingClosingParensIdx + 1;\n    } else {\n      const secondMainConnIdx =\n        this._mainConnectiveIdx(sentArr.slice(matchingClosingParensIdx + 2)) +\n        matchingClosingParensIdx +\n        2;\n      if (\n        sentArr[secondMainConnIdx] === sentArr[matchingClosingParensIdx + 1]\n      ) {\n        return matchingClosingParensIdx + 1;\n      }\n    }\n  }\n};\n\nLogic._matchingClosingParensIdx = function(sentArr, idx) {\n  let openCount = 0;\n  for (let i = idx + 1; i < sentArr.length; i++) {\n    if (sentArr[i] === '(') {\n      openCount++;\n    } else if (sentArr[i] === ')' && openCount > 0) {\n      openCount--;\n    } else if (sentArr[i] === ')' && openCount === 0) {\n      return i;\n    }\n  }\n};\n\nLogic._subsets = function(array) {\n  if (array.length === 0) {\n    return [[]];\n  }\n  const subs = this._subsets(array.slice(0, array.length - 1));\n  const concatted = subs.map(sub => {\n    return sub.concat([array[array.length - 1]]);\n  });\n  return subs.concat(concatted);\n};\n\nLogic._remove = function(sentArr, el) {\n  const idx = sentArr.indexOf(el);\n  if (idx !== -1) sentArr.splice(idx, 1);\n};\n\nLogic._ensureIsArray = function(wff) {\n  if (typeof wff === 'string') {\n    wff = this._parseString(wff);\n  } else if (!(wff instanceof Array)) {\n    return;\n  }\n  return wff;\n};\n\nLogic._ensureIsLegal = function(wff) {\n  for (let i = 0; i < wff.length; i++) {\n    if (!this._vocabulary.includes(wff[i]) && !this._isAtomic(wff[i])) {\n      throw \"Argument can only contain 'N', 'A', 'O', 'T', 'B', 'X', '(', ')', 't', 'f', and numerals (strings of integers)\";\n    }\n  }\n};\n\nexport const isTrue = Logic.isTrue.bind(Logic);\n\nexport const isSat = Logic.isSat.bind(Logic);\n\nexport default Logic;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/boolean-logic/boolean-logic.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}
