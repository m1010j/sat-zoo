{"version":3,"sources":["webpack:///webpack/bootstrap 275632096a7efc2d1730","webpack:///./entry.js","webpack:///./node_modules/boolean-logic/boolean-logic.js"],"names":["generateWffWithOnes","connectives","numAtoms","addNegation","Math","floor","random","connIdx","firstNumAtoms","secondNumAtoms","firstWff","secondWff","negatumWff","generateWffNotDistinct","wff","wffArray","split","i","length","join","generateWff","numNotDistinct","_atomics","benchmark","beforeDate","Date","beforeTime","getTime","result","afterDate","afterTime","duration","Boolean","console","log","document","addEventListener","generateButton","getElementById","submitButton","wffTextarea","resultDiv","e","preventDefault","value"],"mappings":"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AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA","file":"./script.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 275632096a7efc2d1730","import Logic, { isSat } from 'boolean-logic';\n\nexport const generateWffWithOnes = numAtoms => {\n  const connectives = ['N', 'A', 'O', 'X', 'T', 'B'];\n  if (numAtoms === 1) {\n    const addNegation = Math.floor(Math.random()) > 0.5 ? true : false;\n    if (addNegation) {\n      return '(N1)';\n    } else {\n      return '1';\n    }\n  } else if (numAtoms === 2) {\n    let connIdx = Math.floor(Math.random() * 5) + 1;\n    return `(1${connectives[connIdx]}1)`;\n  } else {\n    let connIdx = Math.floor(Math.random() * 6);\n    if (connIdx > 0) {\n      let firstNumAtoms = Math.floor(Math.random() * (numAtoms - 1)) + 1;\n      let secondNumAtoms = numAtoms - firstNumAtoms;\n      let firstWff = generateWffWithOnes(firstNumAtoms);\n      let secondWff = generateWffWithOnes(secondNumAtoms);\n      return `(${firstWff}${connectives[connIdx]}${secondWff})`;\n    } else {\n      let negatumWff = generateWffWithOnes(numAtoms);\n      return `(N${negatumWff})`;\n    }\n  }\n};\n\nexport const generateWffNotDistinct = numAtoms => {\n  const wff = generateWffWithOnes(numAtoms);\n  const wffArray = wff.split('');\n  for (let i = 0; i < wffArray.length; i++) {\n    if (wffArray[i] === '1') {\n      wffArray[i] = Math.floor(Math.random() * numAtoms) + 1;\n    }\n  }\n  return wffArray.join('');\n};\n\nexport const generateWff = numAtoms => {\n  let numNotDistinct = Math.floor(Math.random() * numAtoms * 10) + 1;\n  let wff = generateWffNotDistinct(numNotDistinct);\n  while (Logic._atomics(wff).length !== numAtoms) {\n    numNotDistinct = Math.floor(Math.random() * numAtoms * 10) + 1;\n    wff = generateWffNotDistinct(numNotDistinct);\n  }\n  return wff;\n};\n\nexport const benchmark = wff => {\n  const beforeDate = new Date();\n  const beforeTime = beforeDate.getTime();\n  const result = isSat(wff, true);\n  const afterDate = new Date();\n  const afterTime = afterDate.getTime();\n  const duration = afterTime - beforeTime;\n\n  if (Boolean(result)) {\n    console.log('The formula is satisfiable.');\n    console.log(`The first model found was:`);\n    console.log(result);\n    console.log(`It took ${duration} milliseconds to find this model.`);\n  } else {\n    console.log(\"The formula isn't satisfiable.\");\n    console.log(`It took ${duration} milliseconds to determine this.`);\n  }\n};\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const generateButton = document.getElementById('generateButton');\n  const submitButton = document.getElementById('submitButton');\n  const wffTextarea = document.getElementById('wffTextarea');\n  const resultDiv = document.getElementById('result');\n  generateButton.addEventListener('click', e => {\n    e.preventDefault();\n    const wff = generateWff(5);\n    wffTextarea.value = wff;\n  });\n\n  submitButton.addEventListener('click', e => {\n    e.preventDefault();\n    const result = isSat(wffTextarea.value, true);\n    console.log(result);\n    resultDiv.value = result;\n  });\n});\n\n// const wff = generateWff(15);\n// console.log(`Testing this formula: '${wff}'`);\n// benchmark(wff);\n\n// window.generateWff = generateWff;\n// window.generateWffWithOnes = generateWffWithOnes;\n// window.benchmark = benchmark;\n\n\n\n// WEBPACK FOOTER //\n// ./entry.js","class Logic {\n  constructor(value) {\n    this.value = value;\n    this.parent = null;\n    this.children = [];\n  }\n\n  setParent(parent) {\n    if (this.parent === parent) {\n      return;\n    }\n\n    if (this.parent) {\n      const children = this.parent.children;\n      children._remove(this);\n    }\n\n    this.parent = parent;\n\n    if (this.parent) {\n      this.parent.children.push(this);\n    }\n  }\n\n  addChild(child) {\n    child.setParent(this);\n  }\n\n  removeChild(child) {\n    if (this.children.includes(child)) child.setParent(null);\n  }\n\n  atomic() {\n    return this.children.length === 0 && Logic._isAtomic(this.value);\n  }\n\n  wff() {\n    const connectives = Object.keys(this.constructor._connectives);\n    if (!this.atomic() && !connectives.includes(this.value)) {\n      return false;\n    } else if (this.atomic()) {\n      return true;\n    } else if (\n      this.value === 'N' &&\n      this.children.length === 1 &&\n      this.children[0].wff()\n    ) {\n      return true;\n    } else if (\n      this.constructor._binaryConns.includes(this.value) &&\n      this.children.length === 2 &&\n      this.children[0].wff() &&\n      this.children[1].wff()\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  isTrue(model) {\n    model = model || {};\n    const modelValues = Object.keys(model).map(key => model[key]);\n    for (let i = 0; i < modelValues.length; i++) {\n      if (modelValues[i] !== true && modelValues[i] !== false) {\n        return;\n      }\n    }\n\n    const fullModel = Object.assign(\n      {},\n      model || {},\n      this.constructor._booleans\n    );\n    if (!this.wff()) {\n      return;\n    } else if (this.atomic()) {\n      return fullModel[this.value];\n    } else {\n      const childOne = this.children[0].isTrue(model);\n      let childTwo;\n      if (this.children[1]) childTwo = this.children[1].isTrue(model);\n      const connective = this.constructor._connectives[this.value];\n      return connective(childOne, childTwo);\n    }\n  }\n}\n\nLogic.isTrue = function(array, model) {\n  const parsed = Logic._parse(array);\n  if (!parsed) {\n    return;\n  }\n  return parsed.isTrue(model);\n};\n\nLogic.isSat = function(array, returnModel) {\n  const parsed = Logic._parse(array);\n  if (!parsed) {\n    return;\n  }\n  const models = this._generateModels(array);\n  console.log(\"Done generating models. Finding model.\");\n  for (let i = 0; i < models.length; i++) {\n    if (parsed.isTrue(models[i])) {\n      return returnModel ? models[i] : true;\n    }\n  }\n  return false;\n};\n\nLogic._booleans = {\n  t: true,\n  f: false,\n};\n\nLogic._binaryConns = ['A', 'O', 'T', 'B', 'X'];\n\nLogic._vocabulary = Logic._binaryConns.concat(['N', '(', ')', 't', 'f']);\n\nLogic._connectives = {\n  A: (sentOne, sentTwo) => sentOne && sentTwo,\n  O: (sentOne, sentTwo) => sentOne || sentTwo,\n  T: (sentOne, sentTwo) => !sentOne || sentTwo,\n  B: (sentOne, sentTwo) => (!sentOne || sentTwo) && (!sentTwo || sentOne),\n  X: (sentOne, sentTwo) => (!sentOne && sentTwo) || (sentOne && !sentTwo),\n  N: sentence => !sentence,\n};\n\nLogic._generateModels = function(array) {\n  const atomics = this._atomics(array);\n  const subsets = this._subsets(atomics);\n  return subsets.map(subset => {\n    const newModel = {};\n    atomics.forEach(atomic => {\n      if (subset.includes(atomic)) {\n        newModel[atomic] = false;\n      } else {\n        newModel[atomic] = true;\n      }\n    });\n    return newModel;\n  });\n};\n\nLogic._atomics = function(array) {\n  array = this._ensureIsArray(array);\n  if (!array) {\n    return;\n  }\n  const atomics = [];\n  array.forEach(el => {\n    if (this._isAtomic(el) && !atomics.includes(el)) {\n      atomics.push(el);\n    }\n  });\n  return atomics;\n};\n\nLogic._parse = function(array) {\n  this._ensureIsLegal(array);\n  array = Logic._ensureIsArray(array);\n  if (!array) {\n    throw 'Argument must be either a string or an array';\n  }\n  const mainConnectiveIdx = this._mainConnectiveIdx(array);\n  const mainConnective = array[mainConnectiveIdx];\n  if (array.length === 1 && Logic._isAtomic(array[0])) {\n    return new Logic(array[0]);\n  } else if (\n    array[0] === '(' &&\n    array.length > 3 &&\n    this._matchingClosingParensIdx(array, 0) === array.length - 1\n  ) {\n    if (\n      array[1] === '(' &&\n      this._matchingClosingParensIdx(array, 1) === array.length - 2\n    ) {\n      return;\n    } else {\n      return this._parse(array.slice(1, array.length - 1));\n    }\n  } else if (mainConnectiveIdx === 0) {\n    const prejacent = this._parse(array.slice(1));\n    const connective = new Logic(array[mainConnectiveIdx]);\n    if (prejacent) {\n      connective.addChild(prejacent);\n      return connective;\n    }\n  } else if (mainConnectiveIdx) {\n    const firstConjunct = this._parse(array.slice(0, mainConnectiveIdx));\n    const secondConjunct = this._parse(array.slice(mainConnectiveIdx + 1));\n    if (firstConjunct && secondConjunct) {\n      const connective = new Logic(mainConnective);\n      if (mainConnective) {\n        connective.addChild(firstConjunct);\n        connective.addChild(secondConjunct);\n        return connective;\n      }\n    }\n  }\n};\n\nLogic._parseString = function(str) {\n  const parsed = [];\n  for (let i = 0; i < str.length; i++) {\n    if (this._vocabulary.includes(str[i])) {\n      parsed.push(str[i]);\n    } else {\n      let subStr = '';\n      for (\n        let j = i;\n        j < str.length && !this._vocabulary.includes(str[j]);\n        j++\n      ) {\n        subStr += str[j];\n        i = j;\n      }\n      if (this._isAtomic(subStr)) {\n        parsed.push(subStr);\n      } else {\n        return;\n      }\n    }\n  }\n  return parsed;\n};\n\nLogic._isAtomic = function(str) {\n  if (['t', 'f'].includes(str) || !isNaN(parseInt(str))) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nLogic._mainConnectiveIdx = function(sentArr) {\n  const binaryConns = this._binaryConns;\n  if (sentArr.length === 1) {\n    return;\n  } else if (sentArr[0] === 'I') {\n    const thenIdx = this._mainConnectiveIdx(sentArr.slice(1));\n    if (sentArr[thenIdx + 1] === 'T') {\n      return thenIdx + 1;\n    } else {\n      return;\n    }\n  } else if (\n    sentArr[0] === '(' &&\n    this._matchingClosingParensIdx(sentArr, 0) === sentArr.length - 1\n  ) {\n    if (\n      sentArr[1] === '(' &&\n      this._matchingClosingParensIdx(sentArr, 1) === sentArr.length - 2\n    ) {\n      return;\n    } else {\n      return this._mainConnectiveIdx(sentArr.slice(1, sentArr.length - 1)) + 1;\n    }\n  } else if (\n    sentArr.length === 2 &&\n    sentArr[0] === 'N' &&\n    Logic._isAtomic(sentArr[1])\n  ) {\n    return 0;\n  } else if (\n    sentArr[0] === 'N' &&\n    sentArr[1] === '(' &&\n    this._matchingClosingParensIdx(sentArr, 1) === sentArr.length - 1\n  ) {\n    return 0;\n  } else if (\n    sentArr[0] === 'N' &&\n    sentArr[1] === 'N' &&\n    this._mainConnectiveIdx(sentArr.slice(1)) === 0\n  ) {\n    return 0;\n  } else if (sentArr[0] === 'N' && this._mainConnectiveIdx(sentArr.slice(1))) {\n    return this._mainConnectiveIdx(sentArr.slice(1)) + 1;\n  } else if (\n    sentArr.length === 3 &&\n    Logic._isAtomic(sentArr[0]) &&\n    binaryConns.includes(sentArr[1]) &&\n    Logic._isAtomic(sentArr[2])\n  ) {\n    return 1;\n  } else if (\n    sentArr.length === 3 &&\n    Logic._isAtomic(sentArr[0]) &&\n    binaryConns.includes(sentArr[1]) &&\n    Logic._isAtomic(sentArr[2])\n  ) {\n    return 1;\n  } else if (\n    Logic._isAtomic(sentArr[0]) &&\n    binaryConns.includes(sentArr[1]) &&\n    sentArr[2] === '(' &&\n    this._matchingClosingParensIdx(sentArr, 2) === sentArr.length - 1\n  ) {\n    return 1;\n  } else if (\n    Logic._isAtomic(sentArr[0]) &&\n    binaryConns.includes(sentArr[1]) &&\n    sentArr[2] === 'N'\n  ) {\n    return 1;\n  } else if (\n    Logic._isAtomic(sentArr[0]) &&\n    binaryConns.includes(sentArr[1]) &&\n    sentArr[this._mainConnectiveIdx(sentArr.slice(2)) + 2] === sentArr[1]\n  ) {\n    return 1;\n  } else if (sentArr[0] === '(') {\n    const matchingClosingParensIdx = this._matchingClosingParensIdx(sentArr, 0);\n    if (!matchingClosingParensIdx) {\n      return undefined;\n    } else if (\n      binaryConns.includes(sentArr[matchingClosingParensIdx + 1]) &&\n      Logic._isAtomic(sentArr[matchingClosingParensIdx + 2]) &&\n      sentArr.length === matchingClosingParensIdx + 3\n    ) {\n      return matchingClosingParensIdx + 1;\n    } else if (\n      binaryConns.includes(sentArr[matchingClosingParensIdx + 1]) &&\n      sentArr[matchingClosingParensIdx + 2] === 'N'\n    ) {\n      return matchingClosingParensIdx + 1;\n    } else if (\n      binaryConns.includes(sentArr[matchingClosingParensIdx + 1]) &&\n      sentArr[matchingClosingParensIdx + 2] === '(' &&\n      this._matchingClosingParensIdx(sentArr, matchingClosingParensIdx + 2) ===\n        sentArr.length - 1\n    ) {\n      return matchingClosingParensIdx + 1;\n    } else {\n      const secondMainConnIdx =\n        this._mainConnectiveIdx(sentArr.slice(matchingClosingParensIdx + 2)) +\n        matchingClosingParensIdx +\n        2;\n      if (\n        sentArr[secondMainConnIdx] === sentArr[matchingClosingParensIdx + 1]\n      ) {\n        return matchingClosingParensIdx + 1;\n      }\n    }\n  }\n};\n\nLogic._matchingClosingParensIdx = function(sentArr, idx) {\n  let openCount = 0;\n  for (let i = idx + 1; i < sentArr.length; i++) {\n    if (sentArr[i] === '(') {\n      openCount++;\n    } else if (sentArr[i] === ')' && openCount > 0) {\n      openCount--;\n    } else if (sentArr[i] === ')' && openCount === 0) {\n      return i;\n    }\n  }\n};\n\nLogic._subsets = function(array) {\n  if (array.length === 0) {\n    return [[]];\n  }\n  const subs = this._subsets(array.slice(0, array.length - 1));\n  const concatted = subs.map(sub => {\n    return sub.concat([array[array.length - 1]]);\n  });\n  return subs.concat(concatted);\n};\n\nLogic._remove = function(sentArr, el) {\n  const idx = sentArr.indexOf(el);\n  if (idx !== -1) sentArr.splice(idx, 1);\n};\n\nLogic._ensureIsArray = function(array) {\n  if (typeof array === 'string') {\n    array = this._parseString(array);\n  } else if (!(array instanceof Array)) {\n    return;\n  }\n  return array;\n};\n\nLogic._ensureIsLegal = function(array) {\n  for (let i = 0; i < array.length; i++) {\n    if (!this._vocabulary.includes(array[i]) && !this._isAtomic(array[i])) {\n      throw \"Argument can only contain 'N', 'A', 'O', 'T', 'B', 'X', '(', ')', 't', 'f', and numerals (strings of integers)\";\n    }\n  }\n};\n\nexport const isTrue = Logic.isTrue.bind(Logic);\n\nexport const isSat = Logic.isSat.bind(Logic);\n\nexport default Logic;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/boolean-logic/boolean-logic.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}