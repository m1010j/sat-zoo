{"version":3,"sources":["webpack:///webpack/bootstrap e38ae93d0627172e2b5c","webpack:///./entry.js","webpack:///./node_modules/boolean-logic/boolean-logic.js"],"names":["document","addEventListener","generateButton","getElementById","submitButton","wffTextarea","wffLengthInput","resultDiv","e","preventDefault","wffLength","parseInt","value","wff","generateWff","innerHTML","result","benchmark","attachEvent","checkModels","parsedWff","models","i","length","isTrue","model","modelNumber","beforeParseDate","Date","beforeParseTime","getTime","_parse","afterParseDate","afterParseTime","parseDuration","beforeGenerateModelsDate","beforeGenerateModelsTime","_generateModels","afterGenerateModelsDate","afterGenerateModelsTime","generateModelsDuration","beforeCheckDate","beforeCheckTime","afterCheckDate","afterCheckTime","checkDuration","browserName","navigator","appName","browserEngine","product","browserVersion1a","appVersion","browserVersion1b","userAgent","browserOnline","onLine","browserPlatform","platform","browserInfo","Boolean","resultString","key","nth","num","generateWffWithOnes","numAtoms","connectives","addNegation","Math","floor","random","connIdx","firstNumAtoms","secondNumAtoms","firstWff","secondWff","negatumWff","generateWffNotDistinct","wffArray","split","join","numNotDistinct","_atomics","negationProbability"],"mappings":"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AAN;AACD;AACD,MAAME,sBAAsBf,KAAKE,MAAL,EAA5B;AACA,MAAIa,sBAAsB,GAA1B,EAA+B;AAC7B,WAAOvE,GAAP;AACD,GAFD,MAEO;AACL,kBAAYA,GAAZ;AACD;AACF,C;;;;;;;AC1LD;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA","file":"./script.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e38ae93d0627172e2b5c","import Logic, { isTrue } from 'boolean-logic';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const generateButton = document.getElementById('generateButton');\n  const submitButton = document.getElementById('submitButton');\n  const wffTextarea = document.getElementById('wffTextarea');\n  const wffLengthInput = document.getElementById('wffLength');\n  const resultDiv = document.getElementById('result');\n  generateButton.addEventListener('click', e => {\n    e.preventDefault();\n    const wffLength = parseInt(wffLengthInput.value);\n    const wff = generateWff(wffLength);\n    wffTextarea.value = wff;\n    resultDiv.innerHTML = '';\n  });\n\n  submitButton.addEventListener('click', e => {\n    e.preventDefault();\n    const result = benchmark(wffTextarea.value, resultDiv);\n  });\n\n  if (wffTextarea.addEventListener) {\n    wffTextarea.addEventListener(\n      'input',\n      function() {\n        resultDiv.innerHTML = '';\n      },\n      false\n    );\n  } else if (wffTextarea.attachEvent) {\n    wffTextarea.attachEvent('onpropertychange', function() {\n      resultDiv.innerHTML = '';\n    });\n  }\n});\n\nfunction checkModels(parsedWff, models) {\n  for (let i = 0; i < models.length; i++) {\n    if (parsedWff.isTrue(models[i])) {\n      return {\n        model: models[i],\n        modelNumber: i + 1,\n      };\n    }\n  }\n  return false;\n}\n\nfunction benchmark(wff, resultDiv) {\n  const beforeParseDate = new Date();\n  const beforeParseTime = beforeParseDate.getTime();\n  const parsedWff = Logic._parse(wff, true);\n  const afterParseDate = new Date();\n  const afterParseTime = afterParseDate.getTime();\n  const parseDuration = afterParseTime - beforeParseTime;\n\n  const beforeGenerateModelsDate = new Date();\n  const beforeGenerateModelsTime = beforeGenerateModelsDate.getTime();\n  if (!parsedWff) {\n    return;\n  }\n  const models = Logic._generateModels(wff);\n  const afterGenerateModelsDate = new Date();\n  const afterGenerateModelsTime = afterGenerateModelsDate.getTime();\n  const generateModelsDuration =\n    afterGenerateModelsTime - beforeGenerateModelsTime;\n\n  const beforeCheckDate = new Date();\n  const beforeCheckTime = beforeCheckDate.getTime();\n  const result = checkModels(parsedWff, models);\n  const afterCheckDate = new Date();\n  const afterCheckTime = afterCheckDate.getTime();\n  const checkDuration = afterCheckTime - beforeCheckTime;\n\n  const browserName = navigator.appName;\n  const browserEngine = navigator.product;\n  const browserVersion1a = navigator.appVersion;\n  const browserVersion1b = navigator.userAgent;\n  const browserOnline = navigator.onLine;\n  const browserPlatform = navigator.platform;\n\n  const browserInfo = `\n  <p>Browser name: ${browserName}</p>\n  <p>Browser engine: ${browserEngine}</p>\n  <p>Browser version 1a: ${browserVersion1a}</p>\n  <p>Browser version 1b: ${browserVersion1b}</p>\n  <p>Browser platform: ${browserPlatform}</p>\n  `;\n\n  if (Boolean(result)) {\n    let resultString = '';\n    for (let key in result.model) {\n      resultString = `${resultString}<br />&nbsp;&nbsp;${key}: ${\n        result.model[key]\n      }`;\n    }\n    resultDiv.innerHTML = `\n      <p>The formula is satisfiable.</p>\n      <p>The first model found was:</p>\n      <p>{${resultString}<br />}</p>\n      <p>It took ${parseDuration} milliseconds to parse the wff.</p>\n      <p>\n        It took ${generateModelsDuration} milliseconds to generate all ${\n      models.length\n    } models of this wff.</p>\n      <p>It took ${checkDuration} milliseconds to find the above model.</p>\n      <p>The above model was the ${nth(result.modelNumber)} model checked.</p>\n      ${browserInfo}\n    `;\n  } else {\n    resultDiv.innerHTML = `\n      <p>The formula isn't satisfiable</p>\n      <p>It took ${parseDuration} milliseconds to parse the wff.</p>\n      <p>It took ${generateModelsDuration} milliseconds to generate all ${\n      models.length\n    } models of this wff.</p>\n      <p>It took ${checkDuration} milliseconds to check every model.</p>\n      ${browserInfo}\n    `;\n  }\n}\n\nfunction nth(num) {\n  if (num % 10 === 1) {\n    return `${num}st`;\n  } else if (num % 10 === 2) {\n    return `${num}nd`;\n  }\n  if (num % 10 === 3) {\n    return `${num}rd`;\n  } else {\n    return `${num}th`;\n  }\n}\n\nfunction generateWffWithOnes(numAtoms) {\n  const connectives = ['N', 'A', 'O', 'X', 'T', 'B'];\n  if (numAtoms === 1) {\n    const addNegation = Math.floor(Math.random()) > 0.5 ? true : false;\n    if (addNegation) {\n      return '(N1)';\n    } else {\n      return '1';\n    }\n  } else if (numAtoms === 2) {\n    let connIdx = Math.floor(Math.random() * 5) + 1;\n    return `(1${connectives[connIdx]}1)`;\n  } else {\n    let connIdx = Math.floor(Math.random() * 6);\n    if (connIdx > 0) {\n      let firstNumAtoms = Math.floor(Math.random() * (numAtoms - 1)) + 1;\n      let secondNumAtoms = numAtoms - firstNumAtoms;\n      let firstWff = generateWffWithOnes(firstNumAtoms);\n      let secondWff = generateWffWithOnes(secondNumAtoms);\n      return `(${firstWff}${connectives[connIdx]}${secondWff})`;\n    } else {\n      let negatumWff = generateWffWithOnes(numAtoms);\n      return `(N${negatumWff})`;\n    }\n  }\n}\n\nfunction generateWffNotDistinct(numAtoms) {\n  const wff = generateWffWithOnes(numAtoms);\n  const wffArray = wff.split('');\n  for (let i = 0; i < wffArray.length; i++) {\n    if (wffArray[i] === '1') {\n      wffArray[i] = Math.floor(Math.random() * numAtoms) + 1;\n    }\n  }\n  return wffArray.join('');\n}\n\nfunction generateWff(numAtoms) {\n  let numNotDistinct = Math.floor(Math.random() * numAtoms * 10) + 1;\n  let wff = generateWffNotDistinct(numNotDistinct);\n  while (Logic._atomics(wff).length !== numAtoms) {\n    numNotDistinct = Math.floor(Math.random() * numAtoms * 10) + 1;\n    wff = generateWffNotDistinct(numNotDistinct);\n  }\n  const negationProbability = Math.random();\n  if (negationProbability < 0.5) {\n    return wff;\n  } else {\n    return `(N${wff})`;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./entry.js","class Logic {\n  constructor(value) {\n    this.value = value;\n    this.parent = null;\n    this.children = [];\n  }\n\n  setParent(parent) {\n    if (this.parent === parent) {\n      return;\n    }\n\n    if (this.parent) {\n      const children = this.parent.children;\n      children._remove(this);\n    }\n\n    this.parent = parent;\n\n    if (this.parent) {\n      this.parent.children.push(this);\n    }\n  }\n\n  addChild(child) {\n    child.setParent(this);\n  }\n\n  removeChild(child) {\n    if (this.children.includes(child)) child.setParent(null);\n  }\n\n  atomic() {\n    return this.children.length === 0 && Logic._isAtomic(this.value);\n  }\n\n  wff() {\n    const connectives = Object.keys(this.constructor._connectives);\n    if (!this.atomic() && !connectives.includes(this.value)) {\n      return false;\n    } else if (this.atomic()) {\n      return true;\n    } else if (\n      this.value === 'N' &&\n      this.children.length === 1 &&\n      this.children[0].wff()\n    ) {\n      return true;\n    } else if (\n      this.constructor._binaryConns.includes(this.value) &&\n      this.children.length === 2 &&\n      this.children[0].wff() &&\n      this.children[1].wff()\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  isTrue(model) {\n    model = model || {};\n    const modelValues = Object.keys(model).map(key => model[key]);\n    for (let i = 0; i < modelValues.length; i++) {\n      if (modelValues[i] !== true && modelValues[i] !== false) {\n        return;\n      }\n    }\n\n    const fullModel = Object.assign(\n      {},\n      model || {},\n      this.constructor._booleans\n    );\n    if (!this.wff()) {\n      return;\n    } else if (this.atomic()) {\n      return fullModel[this.value];\n    } else {\n      const childOne = this.children[0].isTrue(model);\n      let childTwo;\n      if (this.children[1]) childTwo = this.children[1].isTrue(model);\n      const connective = this.constructor._connectives[this.value];\n      return connective(childOne, childTwo);\n    }\n  }\n}\n\nLogic.isTrue = function(wff, model) {\n  const parsed = Logic._parse(wff);\n  if (!parsed) {\n    return;\n  }\n  return parsed.isTrue(model);\n};\n\nLogic.isSat = function(wff, returnModel) {\n  const parsedWff = Logic._parse(wff);\n  if (!parsedWff) {\n    return;\n  }\n  const models = this._generateModels(wff);\n  return this._checkModels(parsedWff, models, returnModel);\n};\n\nLogic._checkModels = function(parsedWff, models, returnModel) {\n  for (let i = 0; i < models.length; i++) {\n    if (parsedWff.isTrue(models[i])) {\n      return returnModel ? models[i] : true;\n    }\n  }\n  return false;\n};\n\nLogic._booleans = {\n  t: true,\n  f: false,\n};\n\nLogic._binaryConns = ['A', 'O', 'T', 'B', 'X'];\n\nLogic._vocabulary = Logic._binaryConns.concat(['N', '(', ')', 't', 'f']);\n\nLogic._connectives = {\n  A: (sentOne, sentTwo) => sentOne && sentTwo,\n  O: (sentOne, sentTwo) => sentOne || sentTwo,\n  T: (sentOne, sentTwo) => !sentOne || sentTwo,\n  B: (sentOne, sentTwo) => (!sentOne || sentTwo) && (!sentTwo || sentOne),\n  X: (sentOne, sentTwo) => (!sentOne && sentTwo) || (sentOne && !sentTwo),\n  N: sentence => !sentence,\n};\n\nLogic._generateModels = function(wff) {\n  const atomics = this._atomics(wff);\n  const subsets = this._subsets(atomics);\n  return subsets.map(subset => {\n    const newModel = {};\n    atomics.forEach(atomic => {\n      if (subset.includes(atomic)) {\n        newModel[atomic] = false;\n      } else {\n        newModel[atomic] = true;\n      }\n    });\n    return newModel;\n  });\n};\n\nLogic._atomics = function(wff) {\n  wff = this._ensureIsArray(wff);\n  if (!wff) {\n    return;\n  }\n  const atomics = [];\n  wff.forEach(el => {\n    if (this._isAtomic(el) && !atomics.includes(el)) {\n      atomics.push(el);\n    }\n  });\n  return atomics;\n};\n\nLogic._parse = function(wff) {\n  this._ensureIsLegal(wff);\n  wff = Logic._ensureIsArray(wff);\n  if (!wff) {\n    throw 'Argument must be either a string or an array';\n  }\n  const mainConnectiveIdx = this._mainConnectiveIdx(wff);\n  const mainConnective = wff[mainConnectiveIdx];\n  if (wff.length === 1 && Logic._isAtomic(wff[0])) {\n    return new Logic(wff[0]);\n  } else if (\n    wff[0] === '(' &&\n    wff.length > 3 &&\n    this._matchingClosingParensIdx(wff, 0) === wff.length - 1\n  ) {\n    if (\n      wff[1] === '(' &&\n      this._matchingClosingParensIdx(wff, 1) === wff.length - 2\n    ) {\n      return;\n    } else {\n      return this._parse(wff.slice(1, wff.length - 1));\n    }\n  } else if (mainConnectiveIdx === 0) {\n    const prejacent = this._parse(wff.slice(1));\n    const connective = new Logic(wff[mainConnectiveIdx]);\n    if (prejacent) {\n      connective.addChild(prejacent);\n      return connective;\n    }\n  } else if (mainConnectiveIdx) {\n    const firstConjunct = this._parse(wff.slice(0, mainConnectiveIdx));\n    const secondConjunct = this._parse(wff.slice(mainConnectiveIdx + 1));\n    if (firstConjunct && secondConjunct) {\n      const connective = new Logic(mainConnective);\n      if (mainConnective) {\n        connective.addChild(firstConjunct);\n        connective.addChild(secondConjunct);\n        return connective;\n      }\n    }\n  }\n};\n\nLogic._parseString = function(str) {\n  const parsed = [];\n  for (let i = 0; i < str.length; i++) {\n    if (this._vocabulary.includes(str[i])) {\n      parsed.push(str[i]);\n    } else {\n      let subStr = '';\n      for (\n        let j = i;\n        j < str.length && !this._vocabulary.includes(str[j]);\n        j++\n      ) {\n        subStr += str[j];\n        i = j;\n      }\n      if (this._isAtomic(subStr)) {\n        parsed.push(subStr);\n      } else {\n        return;\n      }\n    }\n  }\n  return parsed;\n};\n\nLogic._isAtomic = function(str) {\n  if (['t', 'f'].includes(str) || !isNaN(parseInt(str))) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nLogic._mainConnectiveIdx = function(sentArr) {\n  const binaryConns = this._binaryConns;\n  if (sentArr.length === 1) {\n    return;\n  } else if (sentArr[0] === 'I') {\n    const thenIdx = this._mainConnectiveIdx(sentArr.slice(1));\n    if (sentArr[thenIdx + 1] === 'T') {\n      return thenIdx + 1;\n    } else {\n      return;\n    }\n  } else if (\n    sentArr[0] === '(' &&\n    this._matchingClosingParensIdx(sentArr, 0) === sentArr.length - 1\n  ) {\n    if (\n      sentArr[1] === '(' &&\n      this._matchingClosingParensIdx(sentArr, 1) === sentArr.length - 2\n    ) {\n      return;\n    } else {\n      return this._mainConnectiveIdx(sentArr.slice(1, sentArr.length - 1)) + 1;\n    }\n  } else if (\n    sentArr.length === 2 &&\n    sentArr[0] === 'N' &&\n    Logic._isAtomic(sentArr[1])\n  ) {\n    return 0;\n  } else if (\n    sentArr[0] === 'N' &&\n    sentArr[1] === '(' &&\n    this._matchingClosingParensIdx(sentArr, 1) === sentArr.length - 1\n  ) {\n    return 0;\n  } else if (\n    sentArr[0] === 'N' &&\n    sentArr[1] === 'N' &&\n    this._mainConnectiveIdx(sentArr.slice(1)) === 0\n  ) {\n    return 0;\n  } else if (sentArr[0] === 'N' && this._mainConnectiveIdx(sentArr.slice(1))) {\n    return this._mainConnectiveIdx(sentArr.slice(1)) + 1;\n  } else if (\n    sentArr.length === 3 &&\n    Logic._isAtomic(sentArr[0]) &&\n    binaryConns.includes(sentArr[1]) &&\n    Logic._isAtomic(sentArr[2])\n  ) {\n    return 1;\n  } else if (\n    sentArr.length === 3 &&\n    Logic._isAtomic(sentArr[0]) &&\n    binaryConns.includes(sentArr[1]) &&\n    Logic._isAtomic(sentArr[2])\n  ) {\n    return 1;\n  } else if (\n    Logic._isAtomic(sentArr[0]) &&\n    binaryConns.includes(sentArr[1]) &&\n    sentArr[2] === '(' &&\n    this._matchingClosingParensIdx(sentArr, 2) === sentArr.length - 1\n  ) {\n    return 1;\n  } else if (\n    Logic._isAtomic(sentArr[0]) &&\n    binaryConns.includes(sentArr[1]) &&\n    sentArr[2] === 'N'\n  ) {\n    return 1;\n  } else if (\n    Logic._isAtomic(sentArr[0]) &&\n    binaryConns.includes(sentArr[1]) &&\n    sentArr[this._mainConnectiveIdx(sentArr.slice(2)) + 2] === sentArr[1]\n  ) {\n    return 1;\n  } else if (sentArr[0] === '(') {\n    const matchingClosingParensIdx = this._matchingClosingParensIdx(sentArr, 0);\n    if (!matchingClosingParensIdx) {\n      return undefined;\n    } else if (\n      binaryConns.includes(sentArr[matchingClosingParensIdx + 1]) &&\n      Logic._isAtomic(sentArr[matchingClosingParensIdx + 2]) &&\n      sentArr.length === matchingClosingParensIdx + 3\n    ) {\n      return matchingClosingParensIdx + 1;\n    } else if (\n      binaryConns.includes(sentArr[matchingClosingParensIdx + 1]) &&\n      sentArr[matchingClosingParensIdx + 2] === 'N'\n    ) {\n      return matchingClosingParensIdx + 1;\n    } else if (\n      binaryConns.includes(sentArr[matchingClosingParensIdx + 1]) &&\n      sentArr[matchingClosingParensIdx + 2] === '(' &&\n      this._matchingClosingParensIdx(sentArr, matchingClosingParensIdx + 2) ===\n        sentArr.length - 1\n    ) {\n      return matchingClosingParensIdx + 1;\n    } else {\n      const secondMainConnIdx =\n        this._mainConnectiveIdx(sentArr.slice(matchingClosingParensIdx + 2)) +\n        matchingClosingParensIdx +\n        2;\n      if (\n        sentArr[secondMainConnIdx] === sentArr[matchingClosingParensIdx + 1]\n      ) {\n        return matchingClosingParensIdx + 1;\n      }\n    }\n  }\n};\n\nLogic._matchingClosingParensIdx = function(sentArr, idx) {\n  let openCount = 0;\n  for (let i = idx + 1; i < sentArr.length; i++) {\n    if (sentArr[i] === '(') {\n      openCount++;\n    } else if (sentArr[i] === ')' && openCount > 0) {\n      openCount--;\n    } else if (sentArr[i] === ')' && openCount === 0) {\n      return i;\n    }\n  }\n};\n\nLogic._subsets = function(array) {\n  if (array.length === 0) {\n    return [[]];\n  }\n  const subs = this._subsets(array.slice(0, array.length - 1));\n  const concatted = subs.map(sub => {\n    return sub.concat([array[array.length - 1]]);\n  });\n  return subs.concat(concatted);\n};\n\nLogic._remove = function(sentArr, el) {\n  const idx = sentArr.indexOf(el);\n  if (idx !== -1) sentArr.splice(idx, 1);\n};\n\nLogic._ensureIsArray = function(wff) {\n  if (typeof wff === 'string') {\n    wff = this._parseString(wff);\n  } else if (!(wff instanceof Array)) {\n    return;\n  }\n  return wff;\n};\n\nLogic._ensureIsLegal = function(wff) {\n  for (let i = 0; i < wff.length; i++) {\n    if (!this._vocabulary.includes(wff[i]) && !this._isAtomic(wff[i])) {\n      throw \"Argument can only contain 'N', 'A', 'O', 'T', 'B', 'X', '(', ')', 't', 'f', and numerals (strings of integers)\";\n    }\n  }\n};\n\nexport const isTrue = Logic.isTrue.bind(Logic);\n\nexport const isSat = Logic.isSat.bind(Logic);\n\nexport default Logic;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/boolean-logic/boolean-logic.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}